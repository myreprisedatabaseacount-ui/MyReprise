const { authenticateSocket } = require('../middleware/socketAuth');
const ConversationService = require('../services/conversationService');
const MessageService = require('../services/messageService');
const ReactionService = require('../services/reactionService');
// ContactsService supprim√© - maintenant g√©r√© par ConversationController
const logger = require('../utils/logger');

// Variable globale pour stocker l'instance Socket.IO
let globalIO = null;

const onlineUsers = new Map();

const initializeSockets = (io) => {
    // Stocker l'instance Socket.IO globalement
    globalIO = io;
    
    // Middleware d'authentification pour tous les sockets
    io.use(authenticateSocket);

    // Envoyer p√©riodiquement la liste des utilisateurs en ligne √† tous les utilisateurs connect√©s
    // pour maintenir la synchronisation (toutes les 30 secondes)
    setInterval(() => {
        if (onlineUsers.size > 0) {
            io.emit('online_users', Object.fromEntries(onlineUsers));
            console.log('üì° Synchronisation p√©riodique des utilisateurs en ligne:', Object.fromEntries(onlineUsers));
        }
    }, 30000);

    io.on('connection', (socket) => {
        const userId = socket.user.userId;
        const userEmail = socket.user.email;

        onlineUsers.set(userId, {
            userId: userId,
            socketId: socket.id,
            connectedAt: new Date()
        });

        // Envoyer la liste des utilisateurs en ligne au nouvel utilisateur
        socket.emit('online_users', Object.fromEntries(onlineUsers));

        // Informer TOUS les utilisateurs connect√©s de la nouvelle liste (y compris le nouvel utilisateur)
        io.emit('online_users', Object.fromEntries(onlineUsers));

        console.log('online_users', Object.fromEntries(onlineUsers));

        logger.info(`üîå Utilisateur connect√©: ${userEmail} (ID: ${userId})`);

        // Stocker l'ID utilisateur dans le socket pour faciliter l'acc√®s
        socket.userId = userId;

        // Rejoindre la room utilisateur pour les notifications personnalis√©es
        socket.join(`user_${userId}`);

        socket.on('join_conversation', async (data) => {
            try {
                const { conversationId } = data;

                if (!conversationId) {
                    socket.emit('error', { message: 'ID de conversation requis' });
                    return;
                }

                // V√©rifier que l'utilisateur peut acc√©der √† cette conversation
                const canAccess = await ConversationService.canAccessConversation(conversationId, userId);
                if (!canAccess) {
                    socket.emit('error', { message: 'Acc√®s refus√© √† cette conversation' });
                    return;
                }

                // Rejoindre la conversation (ajouter √† la room Socket.IO)
                socket.join(`conversation_${conversationId}`);

                // S'assurer que l'utilisateur est bien participant dans la DB
                await ConversationService.joinConversation(conversationId, userId);

                // Obtenir les participants pour informer les autres
                const participants = await ConversationService.getConversationParticipants(conversationId);

                // Informer l'utilisateur qu'il a rejoint
                socket.emit('conversation_joined', {
                    conversationId,
                    message: 'Vous avez rejoint la conversation',
                    participants: participants.map(p => ({
                        id: p.User.id,
                        email: p.User.email,
                        primaryIdentifier: p.User.primaryIdentifier,
                        role: p.role
                    }))
                });

                // Informer les autres participants
                socket.to(`conversation_${conversationId}`).emit('user_joined', {
                    conversationId,
                    user: {
                        id: userId,
                        email: userEmail,
                        primaryIdentifier: socket.user.primaryIdentifier
                    },
                    message: `${userEmail} a rejoint la conversation`
                });

                logger.info(`üë• Utilisateur ${userEmail} a rejoint la conversation ${conversationId}`);

            } catch (error) {
                logger.error('Erreur join_conversation:', error);
                socket.emit('error', { message: 'Erreur lors de la connexion √† la conversation' });
            }
        });

        socket.on('send_message', async (data) => {
            try {
                const { conversationId, text, audioUrl, replyToMessageId, offerId } = data;

                if (!conversationId) {
                    socket.emit('error', { message: 'ID de conversation requis' });
                    return;
                }

                if (!text && !audioUrl) {
                    socket.emit('error', { message: 'Contenu du message requis (texte ou audio)' });
                    return;
                }

                // V√©rifier que l'utilisateur peut acc√©der √† cette conversation
                const canAccess = await ConversationService.canAccessConversation(conversationId, userId);
                if (!canAccess) {
                    socket.emit('error', { message: 'Acc√®s refus√© √† cette conversation' });
                    return;
                }

                // Sauvegarder le message en base de donn√©es
                const message = await MessageService.sendMessage(
                    conversationId,
                    userId,
                    text,
                    audioUrl,
                    replyToMessageId,
                    offerId
                );

                // R√©cup√©rer les informations compl√®tes du message avec l'exp√©diteur
                const { Message } = require('../models/Message');
                const { User } = require('../models/User');
                const fullMessage = await Message.findByPk(message.id, {
                    include: [
                        {
                            model: User,
                            as: 'Sender',
                            attributes: ['id', 'firstName', 'lastName', 'email', 'primaryIdentifier']
                        },
                        {
                            model: Message,
                            as: 'ReplyToMessage',
                            attributes: ['id', 'text', 'sender_id'],
                            include: [{
                                model: User,
                                as: 'Sender',
                                attributes: ['id', 'firstName', 'lastName', 'email', 'primaryIdentifier']
                            }]
                        }
                    ]
                });

                if (fullMessage) {
                    // Envoyer le message √† tous les participants de la conversation
                    io.to(`conversation_${conversationId}`).emit('new_message', {
                        conversationId,
                        message: {
                            id: fullMessage.id,
                            text: fullMessage.text,
                            audioUrl: fullMessage.audio_url,
                            sender: {
                                id: fullMessage.Sender.id,
                                firstName: fullMessage.Sender.firstName,
                                lastName: fullMessage.Sender.lastName,
                                email: fullMessage.Sender.email,
                                primaryIdentifier: fullMessage.Sender.primaryIdentifier
                            },
                            replyToMessage: fullMessage.ReplyToMessage ? {
                                id: fullMessage.ReplyToMessage.id,
                                text: fullMessage.ReplyToMessage.text,
                                sender: {
                                    id: fullMessage.ReplyToMessage.Sender.id,
                                    firstName: fullMessage.ReplyToMessage.Sender.firstName,
                                    lastName: fullMessage.ReplyToMessage.Sender.lastName,
                                    email: fullMessage.ReplyToMessage.Sender.email,
                                    primaryIdentifier: fullMessage.ReplyToMessage.Sender.primaryIdentifier
                                }
                            } : null,
                            offerId: fullMessage.offer_id,
                            createdAt: fullMessage.created_at,
                            isEdited: fullMessage.is_edited
                        }
                    });

                    logger.info(`üí¨ Message envoy√© par ${userEmail} dans conversation ${conversationId}`);
                }

                // Mettre √† jour la liste des conversations pour tous les participants
                await broadcastConversationsUpdate(conversationId);

            } catch (error) {
                logger.error('Erreur send_message:', error);
                socket.emit('error', { message: 'Erreur lors de l\'envoi du message' });
            }
        });

        socket.on('mark_message_read', async (data) => {
            try {
                const { messageId } = data;

                if (!messageId) {
                    socket.emit('error', { message: 'ID de message requis' });
                    return;
                }

                // R√©cup√©rer le message pour obtenir l'ID de conversation
                const message = await MessageService.getMessageById(messageId);
                if (!message) {
                    socket.emit('error', { message: 'Message non trouv√©' });
                    return;
                }

                await MessageService.markMessageAsRead(messageId, userId);

                // Informer les autres participants de la conversation que le message a √©t√© lu
                socket.to(`conversation_${message.conversation_id}`).emit('message_read', {
                    messageId,
                    userId,
                    conversationId: message.conversation_id,
                    readAt: new Date()
                });

                logger.info(`üëÅÔ∏è Message ${messageId} marqu√© comme lu par ${userEmail} dans la conversation ${message.conversation_id}`);

            } catch (error) {
                logger.error('Erreur mark_message_read:', error);
                socket.emit('error', { message: 'Erreur lors du marquage du message' });
            }
        });

        socket.on('toggle_reaction', async (data) => {
            try {
                const { messageId, reactionType } = data;

                if (!messageId || !reactionType) {
                    socket.emit('error', { message: 'ID de message et type de r√©action requis' });
                    return;
                }

                // R√©cup√©rer le message pour obtenir l'ID de conversation
                const message = await MessageService.getMessageById(messageId);
                if (!message) {
                    socket.emit('error', { message: 'Message non trouv√©' });
                    return;
                }

                // V√©rifier que l'utilisateur peut acc√©der √† cette conversation
                const canAccess = await ConversationService.canAccessConversation(message.conversation_id, userId);
                if (!canAccess) {
                    socket.emit('error', { message: 'Acc√®s refus√© √† cette conversation' });
                    return;
                }

                // Toggle la r√©action via le service
                const result = await ReactionService.toggleReaction(messageId, userId, reactionType);
                
                // R√©cup√©rer toutes les r√©actions du message
                const reactions = await ReactionService.getMessageReactionsWithUserStatus(messageId, userId);

                // Informer tous les participants de la conversation
                io.to(`conversation_${message.conversation_id}`).emit('reaction_updated', {
                    messageId,
                    userId,
                    conversationId: message.conversation_id,
                    action: result.action,
                    reactionType: result.reactionType,
                    count: result.count,
                    reactions: reactions,
                    user: {
                        id: userId,
                        firstName: socket.user.firstName,
                        lastName: socket.user.lastName,
                        email: userEmail,
                        primaryIdentifier: socket.user.primaryIdentifier
                    }
                });

                logger.info(`üòÄ R√©action ${reactionType} ${result.action} par ${userEmail} sur message ${messageId} dans conversation ${message.conversation_id}`);

            } catch (error) {
                logger.error('Erreur toggle_reaction:', error);
                socket.emit('error', { message: 'Erreur lors de la gestion de la r√©action' });
            }
        });

        socket.on('delete_message', async (data) => {
            try {
                const { messageId, conversationId } = data;

                if (!messageId || !conversationId) {
                    socket.emit('error', { message: 'ID de message et de conversation requis' });
                    return;
                }

                // R√©cup√©rer le message pour v√©rifier qu'il existe et appartient √† l'utilisateur
                const message = await MessageService.getMessageById(messageId);
                if (!message) {
                    socket.emit('error', { message: 'Message non trouv√©' });
                    return;
                }

                // V√©rifier que l'utilisateur est bien l'exp√©diteur du message
                if (message.sender_id !== userId) {
                    socket.emit('error', { message: 'Vous ne pouvez supprimer que vos propres messages' });
                    return;
                }

                // V√©rifier que l'utilisateur peut acc√©der √† cette conversation
                const canAccess = await ConversationService.canAccessConversation(conversationId, userId);
                if (!canAccess) {
                    socket.emit('error', { message: 'Acc√®s refus√© √† cette conversation' });
                    return;
                }

                // Supprimer le message via le service
                const success = await MessageService.deleteMessage(messageId, userId);
                
                if (success) {
                    // Informer tous les participants de la conversation que le message a √©t√© supprim√©
                    io.to(`conversation_${conversationId}`).emit('message_deleted', {
                        messageId,
                        conversationId,
                        deletedBy: userId,
                        deletedAt: new Date(),
                        user: {
                            id: userId,
                            firstName: socket.user.firstName,
                            lastName: socket.user.lastName,
                            email: userEmail,
                            primaryIdentifier: socket.user.primaryIdentifier
                        }
                    });

                    logger.info(`üóëÔ∏è Message ${messageId} supprim√© par ${userEmail} dans la conversation ${conversationId}`);
                } else {
                    socket.emit('delete_error', { 
                        messageId: messageId,
                        conversationId: conversationId,
                        error: 'Erreur lors de la suppression du message' 
                    });
                }

            } catch (error) {
                logger.error('Erreur delete_message:', error);
                socket.emit('delete_error', { 
                    messageId: messageId,
                    conversationId: conversationId,
                    error: 'Erreur lors de la suppression du message' 
                });
            }
        });

        socket.on('edit_message', async (data) => {
            try {
                const { messageId, text, conversationId } = data;

                logger.info(`‚úèÔ∏è Demande d'√©dition de message ${messageId} par ${userId}`);

                // Validation des donn√©es
                if (!messageId || !text || !conversationId) {
                    socket.emit('edit_error', { 
                        message: 'Donn√©es manquantes', 
                        messageId,
                        conversationId 
                    });
                    return;
                }

                // Validation du texte
                if (text.trim().length === 0) {
                    socket.emit('edit_error', { 
                        message: 'Le message ne peut pas √™tre vide', 
                        messageId,
                        conversationId 
                    });
                    return;
                }

                // R√©cup√©rer le message
                const message = await MessageService.getMessageById(messageId);
                if (!message) {
                    socket.emit('edit_error', { 
                        message: 'Message non trouv√©', 
                        messageId,
                        conversationId 
                    });
                    return;
                }

                // V√©rifier que l'utilisateur est l'exp√©diteur du message
                if (message.sender_id !== userId) {
                    socket.emit('edit_error', { 
                        message: 'Vous ne pouvez √©diter que vos propres messages', 
                        messageId,
                        conversationId 
                    });
                    return;
                }

                // V√©rifier l'acc√®s √† la conversation
                const canAccess = await ConversationService.canAccessConversation(conversationId, userId);
                if (!canAccess) {
                    socket.emit('edit_error', { 
                        message: 'Acc√®s refus√© √† cette conversation', 
                        messageId,
                        conversationId 
                    });
                    return;
                }

                // √âditer le message
                await MessageService.editMessage(messageId, text.trim(), userId);

                // Diffuser l'√©dition √† tous les participants
                globalIO.to(`conversation_${conversationId}`).emit('message_edited', {
                    conversationId,
                    messageId,
                    text: text.trim(),
                    editedBy: userId
                });

                logger.info(`‚úÖ Message ${messageId} √©dit√© par ${userEmail}`);

            } catch (error) {
                logger.error('Erreur edit_message:', error);
                socket.emit('edit_error', { 
                    message: 'Erreur lors de l\'√©dition du message',
                    messageId: data?.messageId,
                    conversationId: data?.conversationId 
                });
            }
        });

        socket.on('leave_conversation', async (data) => {
            try {
                const { conversationId } = data;

                if (!conversationId) {
                    socket.emit('error', { message: 'ID de conversation requis' });
                    return;
                }

                // Quitter la room Socket.IO
                socket.leave(`conversation_${conversationId}`);

                // Marquer comme quitt√© dans la base de donn√©es
                await ConversationService.leaveConversation(conversationId, userId);

                // Informer l'utilisateur
                socket.emit('conversation_left', {
                    conversationId,
                    message: 'Vous avez quitt√© la conversation'
                });

                // Informer les autres participants
                socket.to(`conversation_${conversationId}`).emit('user_left', {
                    conversationId,
                    user: {
                        id: userId,
                        email: userEmail,
                        primaryIdentifier: socket.user.primaryIdentifier
                    },
                    message: `${userEmail} a quitt√© la conversation`
                });

                logger.info(`üëã Utilisateur ${userEmail} a quitt√© la conversation ${conversationId}`);

            } catch (error) {
                logger.error('Erreur leave_conversation:', error);
                socket.emit('error', { message: 'Erreur lors de la sortie de la conversation' });
            }
        });

        // √âv√©nement pour synchroniser les utilisateurs en ligne
        socket.on('sync_online_users', () => {
            socket.emit('online_users', Object.fromEntries(onlineUsers));
            logger.info(`üîÑ Synchronisation des utilisateurs en ligne demand√©e par ${userEmail}`);
        });

        // √âv√©nement pour g√©rer l'indicateur de frappe (typing)
        socket.on('typing_start', (data) => {
            const { conversationId } = data;
            if (conversationId) {
                // Informer tous les autres utilisateurs de la conversation que cet utilisateur tape
                socket.to(`conversation_${conversationId}`).emit('user_typing', {
                    conversationId,
                    userId: userId,
                    userName: userEmail,
                    isTyping: true
                });
                logger.info(`‚å®Ô∏è ${userEmail} commence √† taper dans la conversation ${conversationId}`);
            }
        });

        socket.on('typing_stop', (data) => {
            const { conversationId } = data;
            if (conversationId) {
                // Informer tous les autres utilisateurs de la conversation que cet utilisateur a arr√™t√© de taper
                socket.to(`conversation_${conversationId}`).emit('user_typing', {
                    conversationId,
                    userId: userId,
                    userName: userEmail,
                    isTyping: false
                });
                logger.info(`‚å®Ô∏è ${userEmail} a arr√™t√© de taper dans la conversation ${conversationId}`);
            }
        });

        socket.on('disconnect', (reason) => {
            logger.info(`üîå Utilisateur d√©connect√©: ${userEmail} (ID: ${userId}) - Raison: ${reason}`);
            
            // Retirer l'utilisateur de la liste des utilisateurs en ligne
            onlineUsers.delete(userId);
            
            // Informer TOUS les utilisateurs connect√©s de la liste mise √† jour
            io.emit('online_users', Object.fromEntries(onlineUsers));
            
            logger.info(`üë• Utilisateur ${userEmail} retir√© de la liste des utilisateurs en ligne`);
        });

        socket.on('error', (error) => {
            logger.error(`‚ùå Erreur socket pour utilisateur ${userEmail}:`, error);
        });
    });

    logger.info('‚úÖ Sockets initialis√©s avec succ√®s');
};

/**
 * Diffuser la mise √† jour de la liste des conversations √† tous les participants
 * @param {number} conversationId - ID de la conversation
 */
const broadcastConversationsUpdate = async (conversationId) => {
    try {
        if (!globalIO) {
            logger.warn('Instance Socket.IO non disponible pour le broadcast');
            return;
        }

        // R√©cup√©rer les participants de la conversation
        const participants = await ConversationService.getConversationParticipants(conversationId);
        
        // Pour chaque participant, envoyer la mise √† jour
        for (const participant of participants) {
            const userId = participant.User.id;
            
            // Envoyer la mise √† jour √† l'utilisateur
            globalIO.to(`user_${userId}`).emit('conversations:update', {
                conversationId: conversationId,
                timestamp: new Date(),
                message: 'Nouveau message re√ßu'
            });
        }
        
        logger.info(`üìã Liste des conversations mise √† jour pour la conversation ${conversationId}`);
    } catch (error) {
        logger.error('Erreur lors de la mise √† jour des conversations:', error);
    }
};

module.exports = { initializeSockets, broadcastConversationsUpdate };
